<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jenga KIVA: Torre del Apoyo</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@500;700&family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #F9F9F9;
            --text-color: #4A4A4A;
            --primary: #6a5acd;
            --card-bg: rgba(255,255,255,0.9);
            --shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        /* Modo Oscuro */
        [data-theme="dark"] {
            --bg-color: #0f172a;
            --text-color: #e2e8f0;
            --primary: #a78bfa;
            --card-bg: rgba(30, 41, 59, 0.9);
            --shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            user-select: none;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Bot√≥n Tema */
        .theme-btn {
            position: absolute; top: 20px; right: 20px;
            font-size: 1.5rem; background: none; border: none; cursor: pointer;
            padding: 5px; border-radius: 50%; z-index: 20;
            transition: transform 0.2s;
        }
        .theme-btn:hover { transform: scale(1.1); background: rgba(128,128,128,0.2); }

        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            align-items: center; padding-top: 20px; z-index: 10;
        }

        h1 {
            margin: 0; font-family: 'Fredoka', sans-serif; font-size: 2.2rem;
            color: var(--text-color); text-shadow: 2px 2px 0px rgba(0,0,0,0.1);
            text-align: center;
        }

        p.subtitle {
            margin: 5px 0 15px 0; font-size: 1rem;
            background: var(--card-bg); padding: 5px 15px; border-radius: 20px;
            color: var(--primary); font-weight: bold;
            box-shadow: var(--shadow);
        }

        .btn-group { pointer-events: auto; display: flex; gap: 10px; }

        .game-btn {
            background-color: var(--card-bg);
            border: 2px solid var(--text-color);
            color: var(--text-color);
            padding: 10px 20px;
            font-family: 'Fredoka', sans-serif;
            font-size: 1rem;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 4px 4px 0px var(--primary);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .game-btn:hover { transform: translate(-2px, -2px); box-shadow: 6px 6px 0px var(--primary); }
        .game-btn:active { transform: translate(2px, 2px); box-shadow: 0px 0px 0px; }

        #instructions {
            position: absolute; bottom: 20px; right: 20px;
            background: var(--card-bg); color: var(--text-color);
            padding: 15px; border-radius: 10px; font-size: 0.9rem;
            box-shadow: var(--shadow); pointer-events: none; max-width: 250px;
        }
        
        strong { color: var(--primary); }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>

    <button id="themeToggle" class="theme-btn">üåô</button>

    <div id="ui-container">
        <h1>Torre del Apoyo</h1>
        <p class="subtitle">Construye confianza, bloque a bloque üß±</p>
        <div class="btn-group">
            <button class="game-btn" id="restart-btn">üîÑ Reconstruir</button>
            <button class="game-btn" onclick="window.location.href='index.html'">‚¨Ö Salir</button>
        </div>
    </div>

    <div id="instructions">
        <strong>Reglas KIVA:</strong><br>
        Cada bloque es un valor (Respeto, Amistad).<br>
        ‚Ä¢ üñ±Ô∏è <b>Arrastra</b> con cuidado.<br>
        ‚Ä¢ ¬°Si quitas el soporte, la torre cae!<br>
        ‚Ä¢ Mant√©n el equilibrio.
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        // Tema
        const tBtn = document.getElementById('themeToggle');
        if(localStorage.getItem('theme') === 'dark'){ document.body.setAttribute('data-theme','dark'); tBtn.textContent='‚òÄÔ∏è'; }
        tBtn.addEventListener('click', ()=>{
            const isDark = document.body.getAttribute('data-theme')==='dark';
            document.body.setAttribute('data-theme', isDark ? '' : 'dark');
            localStorage.setItem('theme', isDark ? 'light' : 'dark');
            tBtn.textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
            // Actualizar color de fondo de Three.js
            scene.background = new THREE.Color(isDark ? 0xF9F9F9 : 0x0f172a); 
        });

        // Colores KIVA
        const PALETTE = [0xC8B6FF, 0xB8E1FF, 0xFFC6FF, 0xFFD6A5];

        let scene, camera, renderer, controls;
        let world;
        let timeStep = 1 / 60;
        let meshes = [], bodies = [];
        let raycaster, mouse;
        
        let dragConstraint = null;
        let dragBody = null; 
        let planeIntersector = null; 

        init();
        animate();

        function init() {
            // THREE.JS
            scene = new THREE.Scene();
            // Color inicial seg√∫n tema
            const isDark = document.body.getAttribute('data-theme') === 'dark';
            scene.background = new THREE.Color(isDark ? 0x0f172a : 0xF9F9F9);
            
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(12, 10, 12);
            camera.lookAt(0, 3, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // --- F√çSICA ---
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 15; 
            world.allowSleep = true; 

            const groundMat = new CANNON.Material();
            const blockMat = new CANNON.Material();

            const blockContactMat = new CANNON.ContactMaterial(blockMat, blockMat, {
                friction: 0.05,    
                restitution: 0.0,
                contactEquationStiffness: 1e8,
                contactEquationRelaxation: 3
            });
            
            const groundContactMat = new CANNON.ContactMaterial(groundMat, blockMat, {
                friction: 0.8, 
                restitution: 0.0
            });

            world.addContactMaterial(blockContactMat);
            world.addContactMaterial(groundContactMat);

            // SUELO
            const floorGeo = new THREE.PlaneGeometry(100, 100);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const floorMesh = new THREE.Mesh(floorGeo, floorMat);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);
            
            const floorBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Plane(),
                material: groundMat
            });
            floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(floorBody);

            // √öTILES
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            planeIntersector = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            scene.add(planeIntersector);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);

            document.getElementById('restart-btn').addEventListener('click', createJengaTower);

            createJengaTower();
        }

        function createJengaTower() {
            meshes.forEach(mesh => scene.remove(mesh));
            bodies.forEach(body => world.removeBody(body));
            meshes = [];
            bodies = [];

            const width = 1.0;
            const height = 0.6;
            const length = 3.0;
            const rows = 12;

            const boxShape = new CANNON.Box(new CANNON.Vec3(length/2, height/2, width/2));
            const boxGeo = new THREE.BoxGeometry(length, height, width);
            const blockMat = world.contactmaterials[0].materials[0];

            for (let i = 0; i < rows; i++) {
                const isEven = i % 2 === 0;
                const y = (height / 2) + (i * height);

                for (let j = 0; j < 3; j++) {
                    const offset = (j - 1) * width * 1.05; 

                    const color = PALETTE[Math.floor(Math.random() * PALETTE.length)];
                    const material = new THREE.MeshStandardMaterial({ 
                        color: color,
                        roughness: 0.4,
                        metalness: 0.1
                    });
                    const mesh = new THREE.Mesh(boxGeo, material);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    scene.add(mesh);
                    meshes.push(mesh);

                    const body = new CANNON.Body({
                        mass: 2,
                        shape: boxShape,
                        material: blockMat,
                        linearDamping: 0.1, 
                        angularDamping: 0.1,
                        sleepSpeedLimit: 0.1, 
                        sleepTimeLimit: 1.0   
                    });

                    if (isEven) {
                        body.position.set(0, y, offset);
                        mesh.position.set(0, y, offset);
                    } else {
                        body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI / 2);
                        body.position.set(offset, y, 0);
                        mesh.quaternion.copy(body.quaternion);
                        mesh.position.copy(body.position);
                    }

                    body.sleep(); 

                    world.addBody(body);
                    bodies.push(body);
                    mesh.userData.physicsBody = body;
                }
            }
        }

        // L√ìGICA DE ARRASTRE
        function onPointerDown(event) {
            if (event.target.closest('#ui-container') || event.target.closest('#themeToggle')) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0) {
                controls.enabled = false; 
                const hit = intersects[0];
                const body = hit.object.userData.physicsBody;

                if (body) {
                    body.wakeUp();
                    addMouseConstraint(hit.point.x, hit.point.y, hit.point.z, body);
                    planeIntersector.position.copy(hit.point);
                    planeIntersector.quaternion.copy(camera.quaternion);
                }
            }
        }

        function addMouseConstraint(x, y, z, body) {
            dragBody = new CANNON.Body({ mass: 0, shape: new CANNON.Sphere(0.1) });
            dragBody.position.set(x, y, z);
            world.addBody(dragBody);

            const localPivot = body.pointToLocalFrame(new CANNON.Vec3(x, y, z));
            
            dragConstraint = new CANNON.PointToPointConstraint(
                body, 
                localPivot, 
                dragBody, 
                new CANNON.Vec3(0, 0, 0)
            );
            world.addConstraint(dragConstraint);
        }

        function onPointerMove(event) {
            if (!dragConstraint) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(planeIntersector);

            if (intersects.length > 0) {
                dragBody.position.copy(intersects[0].point);
                dragConstraint.update();
            }
        }

        function onPointerUp() {
            controls.enabled = true; 
            if (dragConstraint) {
                world.removeConstraint(dragConstraint);
                world.removeBody(dragBody);
                dragConstraint = null;
                dragBody = null;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            world.step(timeStep);

            for (let i = 0; i < meshes.length; i++) {
                meshes[i].position.copy(bodies[i].position);
                meshes[i].quaternion.copy(bodies[i].quaternion);
            }
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>